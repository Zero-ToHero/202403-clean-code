# 동시성

동시성

- 동시성(Concurrency)은 Task들이 빠르게 전환하면서 실행되어 동시에 실행되는 것처럼 보이는 것.
- 동시성은 독립적인 작업을 작은 단위의 연산으로 나누어 시간 분할 형태로 연산하고 논리적으로 동시에 실행하는 것처럼 보이게하여 유휴 시간(Idle Time)을 최소화 하는 구조나 개념

쓰레드

- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스 환경.
- 쓰레드는 프로세스 내에서 실행되는 작은 단위를 의미한다. 하나의 프로세스에는 여러 쓰레드가 있을 수 있으며, 각 쓰레드는 독립적으로 실행된다.

임계영역

- 공유되는 자원, 즉 동시접근하려고 하는 자원에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역을 임계영역

단일 스레드는 디버깅하기엔 좋지만 작업효울이 좋지않다. 예를들어 사용자를 처리하는 시스템이 한 요청에 1초가 걸리고 150번 요청이 들어온다고 가정하면 모든 요청을 처리하기에는 150초가 걸린다. 하지만 다중 스레드 방식을 사용해서 동시에 처리하면 응답시간을 높일 수 있다.

---

**동시성의 미신과 오해**

- 동시성은 항상 성능을 높여준다
  - 동시성은 때로 성능을 높여준다, 여러 프로세스가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- 동시성을 구힌해도 설계는 변하지 않는다
  - 단일스레드, 멀티 스레드 시스템 설계는 아에 다르다.
- 웹, 또는 컨테이너를 사용하면 동시성을 이해할 필요가 없다

  - 실제로 어떻게 동작하는지 알아야, 동시수정, 데드락 같은 문제를 해결 할 수있다.

- 동디성은 다소 부하를 유발한다
  - 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다
- 동시성 버그는 재현하기 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고 해야 한다.

---

**동시성 방어 원칙**

- 단일 책임 원칙 (래스, 메소드를 변경할 이유는 1가지여야 한다. 책임이 1개여야 한다.)

  - 동시성 관련 코드도 하나의 책임이니 분리하자

- 공유 자료를 최대한 줄이자

  - 임계영역을 synchronized 키워드로 보호
  - synchronized 키워드가 사용된 메서드나 블록은 임계 영역(critical section)으로 지정된다. 여러 스레드가 임계 영역에 진입하기 위해서는 락(lock)을 획득해야 한다.

- 자료 사본을 사용해라

  - 공유 자료를 복사해서 대체할 수 있는 경우라면, 자료 사본을 사용하는 방법도 가능

- 스레드는 가능한 독립적으로 구현해라

  - 다른 스레드와 자료를 공유하지 않는다

- 라이브러리를 이용하자

  - 자바에선 이미 동시성을 위한 클래스들이 있다. 그걸 사용하자.(java.util.concurrent)

- 실행 모델을 이해하라

  > - 한정된 자원(Bound Resource): 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예이다.
  > - 상호 배제(Mutual Exclusion): 한 번에 한 스레드만 공유 자료나 자원을 사용할 수 있다.
  > - 기아(Starvation): 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
  > - 데드락(Deadlock): 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하기 못한다.
  > - 라이브락(Livelock): 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해 오랫동안 진행하지 못한다.

  - [생산자-소비자](https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C)(여러 스레드가 공유된 자원에 동시에 접근할 때 발생)
  - [독자-저자](https://ko.wikipedia.org/wiki/%EB%8F%85%EC%9E%90-%EC%A0%80%EC%9E%90_%EB%AC%B8%EC%A0%9C)(여러 스레드가 공유된 자원을 동시에 읽거나 쓸 때 발생)
  - [식사하는 철학자들](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)(데드락, 교착상태, 경쟁조건)
  - [잠자는 이발사](https://ko.wikipedia.org/wiki/%EC%9E%A0%EC%9E%90%EB%8A%94_%EC%9D%B4%EB%B0%9C%EC%82%AC_%EB%AC%B8%EC%A0%9C)(데드락, 기아)

- 동기화 메서드 사이에 존재하는 의존성을 이해하라
  - 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생김
  - 필요하다면 고려
    - 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지.
    - 서버에서 잠금 - 서버에다 "서버를 자금고 모든 메서드를 호출 후 잠금을 해제하는" 메서드를 구현. 클라이언트에서 이 메서드 호출
    - 연결 서버 - 중간 서버를 둬서 중간 서버에서 잠금을 수행
- 동기화 부분을 작게 만들어라
  - 임계영역 수를 최대한 줄여야 한다.
- 올바른 종료 코드는 구현이 어렵다.

  - 스레드가 올바르게 종료되지 않고, 이를 알리지 않으면 부모스레드는 자식 스레드를 영원히 기다리는 상황이 발생한다. 그러므로 깔끔하게 종료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현해야 한다(타임아웃 등)

- 스레드 코드 테스트 하기
  - 멀티 스레드 환경에선 이해가 안 가는, 재현이 정말 어려운 에러들이 많이 발생한다. 이를 초기에 잡으려면 테스트를 잘 해야한다.

---

**결론**

- 다중 스레드 코드는 올바로 구현하기 어렵다
- SRP 준수, POJO를 사용해 스레드를 아는 코드 모르는 코드를 분리한다
- 스레드 코드를 테스트 할 때는 전적으로 스레드만 테스트 한다
- 공유 자원을 조작하거나 자원 풀을 공유 할 때 동시성 오류가 발생한다.
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이애한다
- 공유하는 객체 수와 범위를 최대한 줄인다.

---

동시성 해결 방법 (thread-safe)

- **Lock (synchronized, ReentrantLock …)**
- **Database (`비관적 락(Pessimistic)`과 `낙관적 락(Optimistic)` Shared Lock, Exclusive Lock)**
- **MVCC(다중 버전 동시성 제어)**
- **분산락(다중 인스턴스)**

[https://velog.io/@akfls221/동시성에-대한-해결방법을-알아보자](https://velog.io/@akfls221/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)
